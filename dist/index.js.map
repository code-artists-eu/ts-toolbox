{"version":3,"file":"index.js","sources":["../src/array/array.ts","../src/index.ts","../src/math/math.ts","../src/map/lat-long.ts","../src/map/map-tiles.ts","../src/files/files.ts"],"sourcesContent":["export const arrayDiff = (oldArray: string[], newArray: string[]) => {\r\n  return {\r\n    added: newArray.filter(ni => !oldArray?.includes(ni)),\r\n    same: newArray.filter(ni => oldArray.includes(ni)),\r\n    removed: oldArray.filter(oi => !newArray?.includes(oi))\r\n  }\r\n}\r\n\r\nexport const arrayMove = (array: any[], index: number, move: -1 | 1) => {\r\n  const arrayCopy = JSON.parse(JSON.stringify(array))\r\n  const newPosition = index + move\r\n\r\n  if(newPosition > array.length || newPosition < 0) return array\r\n\r\n  arrayCopy[newPosition] = arrayCopy[index]\r\n  arrayCopy[index] = array[newPosition]\r\n\r\n  return arrayCopy\r\n}\r\n\r\nexport const getKey = (data: any, key: string): any => {\r\n  const dotIndex = key.indexOf(\".\")\r\n\r\n  if (dotIndex >= 0) {\r\n    const preKey = key.substr(0, dotIndex)\r\n    const newKey = key.substr(dotIndex + 1)\r\n\r\n    if (!data[preKey]) return null\r\n\r\n    return getKey(data[preKey], newKey)\r\n  }\r\n\r\n  return data[key]\r\n}\r\n","import * as math from \"./math/math\"\nimport * as latLon from \"./map/lat-long\"\nimport * as mapTiles from \"./map/map-tiles\"\nimport * as array from \"./array/array\"\nimport * as files from \"./files/files\"\n\nexport default {\n  math,\n  latLon,\n  mapTiles,\n  array,\n  files\n}\n","export function mapValue(value: number, valMin:number, valMax:number, outMin: number, outMax: number) {\r\n  return outMin + ((value - valMin) * (outMax - outMin)) / (valMax - valMin);\r\n}\r\n\r\nexport function degToRad(degrees: number) {\r\n  return degrees * (Math.PI / 180);\r\n}\r\n","interface LatLong {\r\n  lat: number\r\n  lon: number\r\n}\r\n\r\nexport function calculateDistance(point1: LatLong, point2: LatLong) {\r\n  // Earth's radius in kilometers\r\n  const earthRadius = 6371;\r\n\r\n  // Convert degrees to radians\r\n  const toRadian = (degree: number) => degree * Math.PI / 180;\r\n\r\n  // Convert latitude and longitude from degrees to radians\r\n  const phi1 = toRadian(point1.lat);\r\n  const phi2 = toRadian(point2.lat);\r\n  const deltaPhi = toRadian(point2.lat - point1.lat);\r\n  const deltaLambda = toRadian(point2.lon - point1.lon);\r\n\r\n  // Haversine formula\r\n  const a = Math.sin(deltaPhi / 2) * Math.sin(deltaPhi / 2) +\r\n    Math.cos(phi1) * Math.cos(phi2) *\r\n    Math.sin(deltaLambda / 2) * Math.sin(deltaLambda / 2);\r\n\r\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n\r\n  // Calculate distance in kilometers\r\n  let distance = earthRadius * c;\r\n\r\n  return distance *= 1000; // Convert to meters;\r\n}\r\n","export function latLonToMapTile(lat: number, lon: number, zoom: number) {\r\n  const x = Math.floor((lon + 180) / 360 * Math.pow(2, zoom));\r\n  const y = Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));\r\n  return {x: x, y: y, z: zoom};\r\n}\r\n\r\n\r\nexport function getTileWidthInMeters(zoom: number, lat: number) {\r\n  const earthCircumference = 40075016.686; // in meters\r\n  const numTiles = 2 ** zoom; // number of tiles at given zoom level\r\n  const metersPerTile = earthCircumference / numTiles; // tile width at the equator\r\n\r\n  // Adjust for latitude using the Mercator projection\r\n  const latRad = lat * (Math.PI / 180); // Convert latitude to radians\r\n  const scaleFactor = Math.cos(latRad); // Mercator scale correction\r\n\r\n  return metersPerTile * scaleFactor;\r\n}\r\n","export const b64toBlob = (base64: string): Promise<Blob> => fetch(base64).then((res) => res.blob())\r\n"],"names":["getKey","data","key","dotIndex","indexOf","preKey","substr","newKey","math","value","valMin","valMax","outMin","outMax","degrees","Math","PI","latLon","point1","point2","toRadian","degree","phi1","lat","phi2","deltaPhi","deltaLambda","lon","a","sin","cos","atan2","sqrt","mapTiles","zoom","x","floor","pow","y","log","tan","z","numTiles","latRad","array","oldArray","newArray","added","filter","ni","includes","same","removed","oi","index","move","arrayCopy","JSON","parse","stringify","newPosition","length","files","base64","fetch","then","res","blob"],"mappings":"IAoBaA,EAAS,SAACC,EAAWC,GAChC,IAAMC,EAAWD,EAAIE,QAAQ,KAE7B,GAAID,GAAY,EAAG,CACjB,IAAME,EAASH,EAAII,OAAO,EAAGH,GACvBI,EAASL,EAAII,OAAOH,EAAW,GAErC,OAAKF,EAAKI,GAEHL,EAAOC,EAAKI,GAASE,GAFF,IAG5B,CAEA,OAAON,EAAKC,EACd,iBC3Be,CACbM,8BCPI,SAAmBC,EAAeC,EAAeC,EAAeC,EAAgBC,GACpF,OAAOD,GAAWH,EAAQC,IAAWG,EAASD,IAAYD,EAASD,EACrE,WAEgB,SAASI,GACvB,OAAOA,GAAWC,KAAKC,GAAK,IAC9B,GDEEC,kDEHgCC,EAAiBC,GAEjD,IAGMC,EAAW,SAACC,GAAc,OAAKA,EAASN,KAAKC,GAAK,GAAG,EAGrDM,EAAOF,EAASF,EAAOK,KACvBC,EAAOJ,EAASD,EAAOI,KACvBE,EAAWL,EAASD,EAAOI,IAAML,EAAOK,KACxCG,EAAcN,EAASD,EAAOQ,IAAMT,EAAOS,KAG3CC,EAAIb,KAAKc,IAAIJ,EAAW,GAAKV,KAAKc,IAAIJ,EAAW,GACrDV,KAAKe,IAAIR,GAAQP,KAAKe,IAAIN,GAC1BT,KAAKc,IAAIH,EAAc,GAAKX,KAAKc,IAAIH,EAAc,GAOrD,OALU,EAAIX,KAAKgB,MAAMhB,KAAKiB,KAAKJ,GAAIb,KAAKiB,KAAK,EAAIJ,IAhBjC,KAqBD,GACrB,GFpBEK,kDGT8BV,EAAaI,EAAaO,GAGxD,MAAO,CAACC,EAFEpB,KAAKqB,OAAOT,EAAM,KAAO,IAAMZ,KAAKsB,IAAI,EAAGH,IAEvCI,EADJvB,KAAKqB,OAAO,EAAIrB,KAAKwB,IAAIxB,KAAKyB,IAAIjB,EAAMR,KAAKC,GAAK,KAAO,EAAID,KAAKe,IAAIP,EAAMR,KAAKC,GAAK,MAAQD,KAAKC,IAAM,EAAID,KAAKsB,IAAI,EAAGH,IAC/GO,EAAGP,EACzB,uBAGgB,SAAqBA,EAAcX,GACjD,IACMmB,EAAQ3B,KAAAsB,IAAG,EAAKH,GAIhBS,EAASpB,GAAOR,KAAKC,GAAK,KAGhC,OAR2B,aAEgB0B,EAIvB3B,KAAKe,IAAIa,EAG/B,GHPEC,gCDVuB,SAACC,EAAoBC,GAC5C,MAAO,CACLC,MAAOD,EAASE,OAAO,SAAAC,GAAM,QAAS,MAARJ,GAAAA,EAAUK,SAASD,GAAG,GACpDE,KAAML,EAASE,OAAO,SAAAC,GAAE,OAAIJ,EAASK,SAASD,EAAG,GACjDG,QAASP,EAASG,OAAO,SAAAK,GAAM,QAAS,MAARP,GAAAA,EAAUI,SAASG,MAEvD,YAEyB,SAACT,EAAcU,EAAeC,GACrD,IAAMC,EAAYC,KAAKC,MAAMD,KAAKE,UAAUf,IACtCgB,EAAcN,EAAQC,EAE5B,OAAGK,EAAchB,EAAMiB,QAAUD,EAAc,EAAUhB,GAEzDY,EAAUI,GAAeJ,EAAUF,GACnCE,EAAUF,GAASV,EAAMgB,GAElBJ,EACT,YCPEM,gCIXuB,SAACC,GAAkC,OAAAC,MAAMD,GAAQE,KAAK,SAACC,GAAG,OAAKA,EAAIC,MAAM,EAAC"}
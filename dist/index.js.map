{"version":3,"file":"index.js","sources":["../src/index.ts","../src/math/math.ts","../src/map/lat-long.ts","../src/map/map-tiles.ts"],"sourcesContent":["import * as math from \"./math/math\"\nimport * as latLon from \"./map/lat-long\"\nimport * as mapTiles from \"./map/map-tiles\"\n\nexport default {\n  math,\n  latLon,\n  mapTiles\n}\n","export function mapValue(value: number, valMin:number, valMax:number, outMin: number, outMax: number) {\r\n  return outMin + ((value - valMin) * (outMax - outMin)) / (valMax - valMin);\r\n}\r\n\r\nexport function degToRad(degrees: number) {\r\n  return degrees * (Math.PI / 180);\r\n}\r\n","interface LatLong {\r\n  lat: number\r\n  lon: number\r\n}\r\n\r\nexport function calculateDistance(point1: LatLong, point2: LatLong) {\r\n  // Earth's radius in kilometers\r\n  const earthRadius = 6371;\r\n\r\n  // Convert degrees to radians\r\n  const toRadian = (degree: number) => degree * Math.PI / 180;\r\n\r\n  // Convert latitude and longitude from degrees to radians\r\n  const phi1 = toRadian(point1.lat);\r\n  const phi2 = toRadian(point2.lat);\r\n  const deltaPhi = toRadian(point2.lat - point1.lat);\r\n  const deltaLambda = toRadian(point2.lon - point1.lon);\r\n\r\n  // Haversine formula\r\n  const a = Math.sin(deltaPhi / 2) * Math.sin(deltaPhi / 2) +\r\n    Math.cos(phi1) * Math.cos(phi2) *\r\n    Math.sin(deltaLambda / 2) * Math.sin(deltaLambda / 2);\r\n\r\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n\r\n  // Calculate distance in kilometers\r\n  let distance = earthRadius * c;\r\n\r\n  return distance *= 1000; // Convert to meters;\r\n}\r\n","export function latLonToMapTile(lat: number, lon: number, zoom: number) {\r\n  const x = Math.floor((lon + 180) / 360 * Math.pow(2, zoom));\r\n  const y = Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));\r\n  return {x: x, y: y, z: zoom};\r\n}\r\n\r\n\r\nexport function getTileWidthInMeters(zoom: number, lat: number) {\r\n  const earthCircumference = 40075016.686; // in meters\r\n  const numTiles = 2 ** zoom; // number of tiles at given zoom level\r\n  const metersPerTile = earthCircumference / numTiles; // tile width at the equator\r\n\r\n  // Adjust for latitude using the Mercator projection\r\n  const latRad = lat * (Math.PI / 180); // Convert latitude to radians\r\n  const scaleFactor = Math.cos(latRad); // Mercator scale correction\r\n\r\n  return metersPerTile * scaleFactor;\r\n}\r\n"],"names":["math","value","valMin","valMax","outMin","outMax","degrees","Math","PI","latLon","point1","point2","toRadian","degree","phi1","lat","phi2","deltaPhi","deltaLambda","lon","a","sin","cos","atan2","sqrt","mapTiles","zoom","x","floor","pow","y","log","tan","z","numTiles","latRad"],"mappings":"eAIe,CACbA,8BCLI,SAAmBC,EAAeC,EAAeC,EAAeC,EAAgBC,GACpF,OAAOD,GAAWH,EAAQC,IAAWG,EAASD,IAAYD,EAASD,EACrE,WAEgB,SAASI,GACvB,OAAOA,GAAWC,KAAKC,GAAK,IAC9B,GDAEC,kDEDgCC,EAAiBC,GAEjD,IAGMC,EAAW,SAACC,GAAc,OAAKA,EAASN,KAAKC,GAAK,GAAG,EAGrDM,EAAOF,EAASF,EAAOK,KACvBC,EAAOJ,EAASD,EAAOI,KACvBE,EAAWL,EAASD,EAAOI,IAAML,EAAOK,KACxCG,EAAcN,EAASD,EAAOQ,IAAMT,EAAOS,KAG3CC,EAAIb,KAAKc,IAAIJ,EAAW,GAAKV,KAAKc,IAAIJ,EAAW,GACrDV,KAAKe,IAAIR,GAAQP,KAAKe,IAAIN,GAC1BT,KAAKc,IAAIH,EAAc,GAAKX,KAAKc,IAAIH,EAAc,GAOrD,OALU,EAAIX,KAAKgB,MAAMhB,KAAKiB,KAAKJ,GAAIb,KAAKiB,KAAK,EAAIJ,IAhBjC,KAqBD,GACrB,GFtBEK,kDGP8BV,EAAaI,EAAaO,GAGxD,MAAO,CAACC,EAFEpB,KAAKqB,OAAOT,EAAM,KAAO,IAAMZ,KAAKsB,IAAI,EAAGH,IAEvCI,EADJvB,KAAKqB,OAAO,EAAIrB,KAAKwB,IAAIxB,KAAKyB,IAAIjB,EAAMR,KAAKC,GAAK,KAAO,EAAID,KAAKe,IAAIP,EAAMR,KAAKC,GAAK,MAAQD,KAAKC,IAAM,EAAID,KAAKsB,IAAI,EAAGH,IAC/GO,EAAGP,EACzB,uBAGgB,SAAqBA,EAAcX,GACjD,IACMmB,EAAQ3B,KAAAsB,IAAG,EAAKH,GAIhBS,EAASpB,GAAOR,KAAKC,GAAK,KAGhC,OAR2B,aAEgB0B,EAIvB3B,KAAKe,IAAIa,EAG/B"}
{"version":3,"file":"index.modern.mjs","sources":["../src/array/array.ts","../src/index.ts","../src/math/math.ts","../src/map/lat-long.ts","../src/map/map-tiles.ts","../src/files/files.ts"],"sourcesContent":["export const arrayDiff = (oldArray: string[], newArray: string[]) => {\r\n  return {\r\n    added: newArray.filter(ni => !oldArray?.includes(ni)),\r\n    same: newArray.filter(ni => oldArray.includes(ni)),\r\n    removed: oldArray.filter(oi => !newArray?.includes(oi))\r\n  }\r\n}\r\n\r\nexport const arrayMove = (array: any[], index: number, move: -1 | 1) => {\r\n  const arrayCopy = JSON.parse(JSON.stringify(array))\r\n  const newPosition = index + move\r\n\r\n  if(newPosition > array.length || newPosition < 0) return array\r\n\r\n  arrayCopy[newPosition] = arrayCopy[index]\r\n  arrayCopy[index] = array[newPosition]\r\n\r\n  return arrayCopy\r\n}\r\n\r\nexport const getKey = (data: any, key: string): any => {\r\n  const dotIndex = key.indexOf(\".\")\r\n\r\n  if (dotIndex >= 0) {\r\n    const preKey = key.substr(0, dotIndex)\r\n    const newKey = key.substr(dotIndex + 1)\r\n\r\n    if (!data[preKey]) return null\r\n\r\n    return getKey(data[preKey], newKey)\r\n  }\r\n\r\n  return data[key]\r\n}\r\n","import * as math from \"./math/math\"\nimport * as latLon from \"./map/lat-long\"\nimport * as mapTiles from \"./map/map-tiles\"\nimport * as array from \"./array/array\"\nimport * as files from \"./files/files\"\n\nexport default {\n  math,\n  latLon,\n  mapTiles,\n  array,\n  files\n}\n","export function mapValue(value: number, valMin:number, valMax:number, outMin: number, outMax: number) {\r\n  return outMin + ((value - valMin) * (outMax - outMin)) / (valMax - valMin);\r\n}\r\n\r\nexport function degToRad(degrees: number) {\r\n  return degrees * (Math.PI / 180);\r\n}\r\n","interface LatLong {\r\n  lat: number\r\n  lon: number\r\n}\r\n\r\nexport function calculateDistance(point1: LatLong, point2: LatLong) {\r\n  // Earth's radius in kilometers\r\n  const earthRadius = 6371;\r\n\r\n  // Convert degrees to radians\r\n  const toRadian = (degree: number) => degree * Math.PI / 180;\r\n\r\n  // Convert latitude and longitude from degrees to radians\r\n  const phi1 = toRadian(point1.lat);\r\n  const phi2 = toRadian(point2.lat);\r\n  const deltaPhi = toRadian(point2.lat - point1.lat);\r\n  const deltaLambda = toRadian(point2.lon - point1.lon);\r\n\r\n  // Haversine formula\r\n  const a = Math.sin(deltaPhi / 2) * Math.sin(deltaPhi / 2) +\r\n    Math.cos(phi1) * Math.cos(phi2) *\r\n    Math.sin(deltaLambda / 2) * Math.sin(deltaLambda / 2);\r\n\r\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n\r\n  // Calculate distance in kilometers\r\n  let distance = earthRadius * c;\r\n\r\n  return distance *= 1000; // Convert to meters;\r\n}\r\n","export function latLonToMapTile(lat: number, lon: number, zoom: number) {\r\n  const x = Math.floor((lon + 180) / 360 * Math.pow(2, zoom));\r\n  const y = Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));\r\n  return {x: x, y: y, z: zoom};\r\n}\r\n\r\n\r\nexport function getTileWidthInMeters(zoom: number, lat: number) {\r\n  const earthCircumference = 40075016.686; // in meters\r\n  const numTiles = 2 ** zoom; // number of tiles at given zoom level\r\n  const metersPerTile = earthCircumference / numTiles; // tile width at the equator\r\n\r\n  // Adjust for latitude using the Mercator projection\r\n  const latRad = lat * (Math.PI / 180); // Convert latitude to radians\r\n  const scaleFactor = Math.cos(latRad); // Mercator scale correction\r\n\r\n  return metersPerTile * scaleFactor;\r\n}\r\n","export const b64toBlob = (base64: string): Promise<Blob> => fetch(base64).then((res) => res.blob())\r\n"],"names":["getKey","data","key","dotIndex","indexOf","preKey","substr","newKey","arrayDiff","oldArray","newArray","added","filter","ni","includes","same","removed","oi","arrayMove","array","index","move","arrayCopy","JSON","parse","stringify","newPosition","length","math","value","valMin","valMax","outMin","outMax","degrees","Math","PI","latLon","point1","point2","toRadian","degree","phi1","lat","phi2","deltaPhi","deltaLambda","lon","a","sin","cos","atan2","sqrt","mapTiles","zoom","x","floor","pow","y","log","tan","z","latRad","files","base64","fetch","then","res","blob"],"mappings":"AAAO,MAoBMA,EAASA,CAACC,EAAWC,KAChC,MAAMC,EAAWD,EAAIE,QAAQ,KAE7B,GAAID,GAAY,EAAG,CACjB,MAAME,EAASH,EAAII,OAAO,EAAGH,GACvBI,EAASL,EAAII,OAAOH,EAAW,GAErC,OAAKF,EAAKI,GAEHL,EAAOC,EAAKI,GAASE,OAC9B,CAEA,OAAON,EAAKC,EAAG,kCAhCQM,CAACC,EAAoBC,KACrC,CACLC,MAAOD,EAASE,OAAOC,KAAOJ,MAAAA,GAAAA,EAAUK,SAASD,KACjDE,KAAML,EAASE,OAAOC,GAAMJ,EAASK,SAASD,IAC9CG,QAASP,EAASG,OAAOK,KAAe,MAARP,GAAAA,EAAUI,SAASG,iBAI9BC,CAACC,EAAcC,EAAeC,KACrD,MAAMC,EAAYC,KAAKC,MAAMD,KAAKE,UAAUN,IACtCO,EAAcN,EAAQC,EAE5B,OAAGK,EAAcP,EAAMQ,QAAUD,EAAc,EAAUP,GAEzDG,EAAUI,GAAeJ,EAAUF,GACnCE,EAAUF,GAASD,EAAMO,GAElBJ,cCXMF,EAAA,CACbQ,8BCPI,SAAmBC,EAAeC,EAAeC,EAAeC,EAAgBC,GACpF,OAAOD,GAAWH,EAAQC,IAAWG,EAASD,IAAYD,EAASD,EACrE,WAEgB,SAASI,GACvB,OAAOA,GAAWC,KAAKC,GAAK,IAC9B,GDEEC,kDEHgCC,EAAiBC,GAEjD,MAGMC,EAAYC,GAAmBA,EAASN,KAAKC,GAAK,IAGlDM,EAAOF,EAASF,EAAOK,KACvBC,EAAOJ,EAASD,EAAOI,KACvBE,EAAWL,EAASD,EAAOI,IAAML,EAAOK,KACxCG,EAAcN,EAASD,EAAOQ,IAAMT,EAAOS,KAG3CC,EAAIb,KAAKc,IAAIJ,EAAW,GAAKV,KAAKc,IAAIJ,EAAW,GACrDV,KAAKe,IAAIR,GAAQP,KAAKe,IAAIN,GAC1BT,KAAKc,IAAIH,EAAc,GAAKX,KAAKc,IAAIH,EAAc,GAOrD,OALU,EAAIX,KAAKgB,MAAMhB,KAAKiB,KAAKJ,GAAIb,KAAKiB,KAAK,EAAIJ,IAhBjC,KAqBD,GACrB,GFpBEK,kDGT8BV,EAAaI,EAAaO,GAGxD,MAAO,CAACC,EAFEpB,KAAKqB,OAAOT,EAAM,KAAO,IAAMZ,KAAKsB,IAAI,EAAGH,IAEvCI,EADJvB,KAAKqB,OAAO,EAAIrB,KAAKwB,IAAIxB,KAAKyB,IAAIjB,EAAMR,KAAKC,GAAK,KAAO,EAAID,KAAKe,IAAIP,EAAMR,KAAKC,GAAK,MAAQD,KAAKC,IAAM,EAAID,KAAKsB,IAAI,EAAGH,IAC/GO,EAAGP,EACzB,gCAGqCA,EAAcX,GACjD,MAKMmB,EAASnB,GAAOR,KAAKC,GAAK,KAGhC,OAR2B,aACV,GAAKkB,EAKFnB,KAAKe,IAAIY,EAG/B,GHPE3C,QACA4C,gCIXwBC,GAAkCC,MAAMD,GAAQE,KAAMC,GAAQA,EAAIC"}